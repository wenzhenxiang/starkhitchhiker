# Stark数学：算术化2

原文链接

[https://medium.com/starkware/arithmetization-ii-403c3b3f4355](https://medium.com/starkware/arithmetization-ii-403c3b3f4355 "https://medium.com/starkware/arithmetization-ii-403c3b3f4355")

## “我们需要更深入”

这是我们 STARK 数学系列的第三篇文章，如果您还没有阅读[第一](https://medium.com/starkware/stark-math-the-journey-begins-51bd2b063c71 "第一")篇和[第二篇](https://medium.com/starkware/arithmetization-i-15c046390862 "第二篇")文章，我们建议你在继续阅读之前先阅读。注意：此文比前文要涉及更多数学知识。

![照片由Iswanto Arif在Unsplash上拍摄](https://miro.medium.com/max/700/1*Y6du7Co1odhStqxuGp31hQ.jpeg "照片由Iswanto Arif在Unsplash上拍摄")

# 回顾

在[上](https://medium.com/starkware/arithmetization-i-15c046390862 "上")一篇文章中，我们介绍了算术化——将计算完整性 (CI) 语句转换为检查多项式是否为低度的过程。这种转换使我们能够实现简洁的验证，其中 CI 语句的验证者需要的资源比简单回放所需的资源要少得多。[在上一篇文章中，我们通过将有关Collatz 序列](https://en.wikipedia.org/wiki/Collatz_conjecture "在上一篇文章中，我们通过将有关Collatz 序列")的 CI 语句转换为执行轨迹和一组多项式约束的示例，放大了此转换的第一步。在这篇文章中，我们采取下一步行动并展示——这一次使用[斐波那契数列](https://en.wikipedia.org/wiki/Fibonacci_number "斐波那契数列")——证明者如何结合执行轨迹和多项式约束来获得一个保证为低度的多项式，当且仅当执行轨迹满足我们开始的多项式约束时。此外，我们将展示考虑多项式的域如何允许验证者简洁地赋值（evaluation) 它。我们还简要讨论了纠错码如何在 STARK 中发挥作用。我们将假设你熟悉有限群、有限域上的多项式以及本系列的前几篇文章。


# 查询和纠错码

回想一下，我们的目标是让验证者可以向证明者提出非常少量的问题，并在保证高度准确性的情况下决定是接受还是拒绝证明。理想情况下，验证者希望要求证明者在执行轨迹中的几个（随机）位置提供值，并检查这些位置的多项式约束是否成立。一个正确的执行轨迹自然会通过这个测试。然而，构造一个完全错误的执行轨迹并不难，它可以只在一个地方违反了约束条件，这样做会得到一个完全不同的结果。通过少量随机查询来识别此故障是非常不可能的。

解决类似问题的常用技术是[纠错码](https://en.wikipedia.org/wiki/Error_detection_and_correction "纠错码")。

纠错码通过用更长的字符串替换原始字符串，将一组字符串（其中一些可能彼此非常相似）转换为成对非常不同的一组字符串。

有趣的是，多项式可用于构建良好的纠错码，因为在比 d 大得多的域上赋值的两个 d 阶多项式，他们几乎在所有地方都不同¹。这样的代码称为[Reed-Solomon](https://en.wikipedia.org/wiki/Reed–Solomon_error_correction "Reed-Solomon")码。

观察到这一点，我们可以通过将执行轨迹视为对某个域上的多项式的赋值，并在更大的域上估算该多项式来扩展执行轨迹。以类似的方式扩展不正确的执行轨迹会产生一个截然不同的字符串，这反过来又使验证者可以使用少量查询来区分这些情况。

因此，我们的计划是&#x20;

1\) 将执行轨迹改写为多项式，

2\) 将其扩展到一个大域，以及&#x20;

3\) 使用多项式约束将其转换为另一个多项式，当且仅如果执行轨迹有效，该多项式保证是低阶的

# 简单例子：布尔执行轨迹

假设有问题的 CI 语句是“证明者有一个由 512 个数字组成的序列，所有这些数字都是 0 或 1”，我们想通过读取少于 512 个数字来验证这一点。让我们看看什么样的执行轨迹和多项式约束能表达这个示例：

1.  执行轨迹有 512 行，每行包含一个包含 0 或 1 的单元格。
2.  在这里我们使用的多项式约束很简单*Aᵢ ⋅ Aᵢ-Aᵢ=0*，其中Aᵢ表示此单列执行轨迹中的第 i 个单元格（一个数字等于它的平方当且仅当它是 0 或 1） 。

为了用多项式重新表述这个**执行轨迹，我们指定了我们将要处理的字段——我们使用** $Z₉₆₇₆₉$ ，从整数 0,1,...,96768 的集合中获得，加法和乘法模数为 96769。接下来我们选择 $Z₉₆₇₆₉$ \**的子群G*（我们使用F\*来表示 F 的乘法群² ）*使得*|G|=512和G的一些生成元³ *g*。这样一个子群的存在是有保证的，因为 512 划分了这个群的大小（即 96768）。

我们现在将执行轨迹中的元素视为对某个阶数小于 512 的多项式f(x)*的赋值，方法如下：第 i 个单元格包含对生成元的 i 次幂的f的赋值。*

正式地：

![](https://miro.medium.com/max/700/1*mzkuvaZBOAD5Ans85KpfYA.png)

这种最多 512 阶的多项式可以通过插值计算，然后我们继续在更大的域上赋值它⁴，形成 Reed-Solomon 码的特殊情况。

最后，我们使用这个多项式来创建另一个多项式，其低度取决于在执行轨迹上满足的约束。

为此，我们必须先讨论多项式的根。

# 多项式的根

关于多项式及其根的一个基本事实是，如果p(x)*是一个多项式，则对于某个特定值a ，p(a)=0*，**当且仅当**存在一个多项式 q(x)，*使得*(x-a)q (x)=p(x)*和 deg(p)=deg(q)+1* （deg指度数）。

此外，对于所有x≠a，我们可以通过计算来赋值q(x)：

![](https://miro.medium.com/max/700/1*ca8-ZL_MH6wGJi_kaHmJgA.png)

通过归纳，类似的事实也适用于k个根。即，如果 aᵢ 是所有i=0..k-1的p的根，则存在度数为deg(p)-k的多项式q，并且在除这些k值之外的所有值中，它完全等于

![](https://miro.medium.com/max/700/1*DZv4mVC-Q-cwVbV0o5JF9Q.png)

# 把它放在一起

根据f重新表述多项式约束产生以下多项式：

![](https://miro.medium.com/max/700/1*cslGw8rCbpWYt6_J4gzgbA.png)

我们定义了f使得这个表达式的根是1, g, g², …, g⁵¹¹当且仅当执行轨迹中的单元格是 0 或 1。我们可以定义：

![](https://miro.medium.com/max/700/1*GVve2ykJllJIrbBuirCagQ.png)

而且我们从上一段中知道，当且仅当执行轨迹是一个 512 位的列表（即 0 或 1），*存在一个多项式，*其度数**最多**为*2* · deg(f)-512，在所有 x ∉{ *1, g, g², ..., g⁵¹¹}的点上都与p保持一致* 。请注意，前面，证明者已将执行轨迹扩展到更大的域，因此查询该域中的多项式值是明确定义的。

如果存在一种协议，证明者可以通过该协议让验证者相信这个多项式是低阶的，这样验证者只要求执行轨迹之外的值，那么只有当 CI 声明为真时，验证者才会确信 CI 声明的真实性。事实上，在下一篇文章中，我们将展示一个完全可以做到这一点的协议，而且出错的概率非常小。暂时——让我们看另一个例子，它仍然很简单，但并非完全无关紧要，看看在这种情况下减少是如何工作的。&#x20;

# 斐波那契数列

我们接下来使用的示例是正确计算 $Z_{96769}$ 到第 512 位的斐波那契数列。该序列正式定义为：

![](https://miro.medium.com/max/700/1*vbcLUi--i3IfFzThJioQKg.png)

我们的主张（即 CI statement ）是 $ a_{511}=62215  $。

我们可以通过简单地写下所有 512 个数字来为此 CI statement 创建**执行轨迹：**

![](https://miro.medium.com/max/700/1*wZf7_yRYWaF2AFy8V-128w.png)

我们使用的**多项式约束**是

![](https://miro.medium.com/max/700/1*_oCV7Mn0Kmp6wMJW8RtBuw.png)

# 转换为多项式

在这里，我们也定义了一个最多为 512 阶的多项式f(x)，这样**执行轨迹中的元素就是**f在某个生成元 g 的幂中的求值。

正式地：

![](https://miro.medium.com/max/700/1*m2mInqSpGGKE9gMUJ1sYtQ.png)

用f而不是A来表达**多项式约束**，我们得到：

![](https://miro.medium.com/max/700/1*8CRYGCOU5FvLfVYe9H5UmQ.png)

由于多项式的组合仍然是多项式 - 用f(gⁱ)替换约束中的Aᵢ仍然意味着这些是多项式约束。

请注意，1、2 和 4 是引用单个f值的约束，我们将它们称为边界约束。

相比之下，斐波那契递归关系体现了对整个执行轨迹的一组约束，并且它可以替代地改写为：

![](https://miro.medium.com/max/700/1*UX5bkxMyy_i6hPOQsoR3XA.png)

使用生成元来索引执行轨迹的行允许我们将“下一行”的概念编码为简单的代数关系。如果x是执行轨迹中的某行，则 $gx$ 是下一行， $g^2x$ 是下行之后的行， $g^{-1}x$ 是前一行，依此类推。

递归关系多项式： $f(g^2x)-f(gx)-f(x)$ 对于在执行轨迹中索引行的每个x为零，除了最后两个。这意味着 $1, g, g², …, g⁵⁰⁹$ 都是这个递归关系多项式的根（并且它的阶数最多为 510），所以我们可以构造q(x)如下：

![](https://miro.medium.com/max/700/1*qe6fNMFryaYpSZvJBfjWVw.png)

在 STARK 中，这通常被称为**组合多项式**。实际上，当原始执行轨迹遵循斐波那契递归关系时，该表达式与除了以下 510 个值（$1、g、g^2、 …，g^{509}$）之外的所有值的度数最多为 2 的某个多项式（回想一下，f的阶数最多为 512）一致。然而，组合多项式这个术语有点误导，因为当执行轨迹不满足多项式约束时——这个表达式的估算在许多地方都不同于**任何低阶多项式**。换句话说，当且仅当原始 CI 正确时，它才接近低阶多项式，这是我们的目标。

关于承诺的减少到此结束，将检查某些多项式约束是否在某些执行轨迹上满足的问题转换为检查某些多项式（证明者已知）是否为低度的问题。

# 简洁

拥有一种非常有效的验证技术是 STARK 的关键，它可以被视为由两部分组成——使用少量查询，以及让验证者对每个查询执行少量计算。前者是通过纠错码实现的，它允许在很少的地方进行查询，而后者我们在这篇文章中一直在隐藏下进行，直到现在。验证者的工作可以总结为 1）在随机位置查询组合多项式，以及 2）基于这些查询检查低度。低度简洁检查将在下一篇文章中处理，但我们所说的“查询组合多项式”到底是什么意思？狂热的读者可能对这种表达方式持怀疑态度，这是理所当然的。毕竟，证明者可能是恶意的。组合多项式。

为了防止这种情况，验证器通过在三个位置询问 $f$ 的值来显式查询 $w$ 某行的斐波那契执行轨迹： $f(w)$*、*$f(gw)$*、*$f(g^2w)$$.$

验证者现在可以通过以下方式计算 $w$ 处的组合多项式的值：

![](https://miro.medium.com/max/700/1*hof_70255VU2PowlZvCI_w.png)

分子可以使用从证明者获得的值来计算，而分母……嗯，有问题（先规避一下，后续说明）。

一方面，分母完全独立于执行轨迹，因此验证者可以在与证明者通信之前计算它。

另一方面，实际上——轨迹可能由数十万行组成，计算分母会使验证者在运行时间上付出高昂的代价。

这就是算术化对于简洁性至关重要的地方——因为如果注意到以下情况，可以非常有效地为 g 的幂形成子群的特殊情况计算这个表达式：

![](https://miro.medium.com/max/700/1*PfklJ-8Ha32DJwqK-mpGZg.png)

这个等式是正确的（译者注: 这个等式是群的性质之一），因为两边都是|G|的多项式。其根正是 G 的元素。

等式的右边似乎需要一些在 |G|中**线性**的计算运行时间。但是，如果我们通过快速密算法，例该等式的左侧可以实现用 |G|中**对数**的计算运行时间（译者注:右边需要的计算阶数和群的大小是线性相关的，左边的计算阶数是群的大小的对数 log|G|）。

此问题的斐波那契组合多项式的实际分母可以通过将其重写为：

![](https://miro.medium.com/max/700/1*G4bayseLR0d5DZ_S26azww.png)

这个技术性的问题是验证器能够在多对数时间内运行的核心，它之所以启用，是因为我们将执行轨迹视为对该域的某个子群的多项式的赋值，并且所讨论的多项式约束适用于该子群。

类似的技巧可以应用于更复杂的执行轨迹，但约束的重复模式与域的某些子群重合是至关重要的。

# 更多约束，更多列！

这篇文章中的示例是有意简单举例的，以突出算术化的关键方面。一个自然而然的问题将是：如何处理多列和多个约束的情况。答案很简单：多列仅仅意味着有不止一个多项式可以使用，多个组合多项式——由多个约束产生——被组合成一个多项式，所有这些多项式的随机线性组合，为了STARK 的最后一个阶段，那就是低度测试。当且仅当它的所有组件都是这样时，线性组合的概率很高。

# 总结

我们已经展示了在给定执行轨迹和约束多项式的情况下，证明者如何构造一个低度多项式，当且仅当原始 CI 语句成立时。此外，我们已经展示了验证者如何有效地查询这个多项式的值，确保证明者没有用一些假的低阶多项式替换真正的多项式。

在下一篇文章中，将详细介绍低度测试，展示如何完成查询少量值并确定某个多项式是否为低度的魔法。

*Shir Peled*

*StarkWare*

翻译:

Xiang&#x20;

¹要看到这一点，请注意不同的 d 阶多项式之间的差异是 d 阶的非零多项式，因此最多有 d 个零。

²提醒：乘法群是从字段中省略零元素得到的。

³生成元是子群中的一个元素，其权力跨越整个子群。

⁴选择这个域的大小直接转化为健全性误差，它越大——健全性误差越小。

⁵这样当且仅当证明者没有作弊时，验证者才会被说服。
