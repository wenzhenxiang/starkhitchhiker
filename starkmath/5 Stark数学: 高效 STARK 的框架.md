高效 STARK 的框架

结合概率证明和哈希函数

![](image/image_ySlAUNsI4L.png)

这是我们 STARK 数学系列的第五篇也是最后一篇文章。

在[我们的第一篇文章](https://medium.com/starkware/stark-math-the-journey-begins-51bd2b063c71 "我们的第一篇文章")中，我们介绍了包容性问责制的概念，以及它对公链的重要性。我们还解释了为什么 STARK 的可扩展性特性能够实现这一概念。我们建议读者在继续之前阅读第一篇文章。

在我们的第二、第三和第四篇文章中，我们深入探讨了 STARK 背后的数学理论。我们解释了如何[将计算语句转换为多项式约束](https://medium.com/starkware/arithmetization-i-15c046390862 "将计算语句转换为多项式约束")。我们解释了如何[减少检查多项式约束以检查低度](https://medium.com/starkware/arithmetization-ii-403c3b3f4355 "减少检查多项式约束以检查低度")。我们描述了一个[有效的低度测试](https://medium.com/starkware/low-degree-testing-f7614f5172db "有效的低度测试")。下面我们假设不熟悉这些帖子，除了一个部分解释了这些帖子中描述的协议如何被视为某种类型的概率证明（其细节在本文中无关紧要）。

在这篇文章中，我们通过重新审视 STARK 的概念，然后解释如何从**概率证明**和**加密哈希函数**构造 STARK 来结束该系列。

## 我们的目标：可扩展的透明参数

我们希望构建一个 STARK，它是一个既可**扩展**又**透明**的加密证明（又名“argument”） 。我们的[第一篇文章](https://medium.com/starkware/stark-math-the-journey-begins-51bd2b063c71 "第一篇文章")详细描述了这个目标，我们现在对其进行总结。

我们考虑计算完整性 (CI) 语句的密码证明。这意味着，对于给定的程序𝐀、输入x、输出y和时间限制T，我们希望生成一个证明字符串 𝛑 来证明该语句

*“𝐀* ( *x ) 在T个计算步骤内输出y ”。*

没有（有效的）程序应该能够为错误的陈述产生看起来有效的证明（例如，声称𝐀（*x*）=1，而𝐀（*x*）=0）。更一般的 CI 语句是可能的，其中𝐀还需要一个私人辅助输入，但我们在这篇文章中忽略了这一点。

![](https://miro.medium.com/max/1398/1*lw1iNrP3wzg9Dh2iwE2F5Q.png)

**图 1**：STARK 示意图。

STARK 是满足以下理想属性的密码证明。

-   **可扩展性：**产生𝛑需要的时间是T·polylog( *T* )，而验证𝛑需要的时间只有polylog( *T* )；特别是，𝛑 的长度是 polylog( *T* )。换句话说，生成证明并不比只运行原始计算贵多少，验证证明比运行原始计算**要快得多**。证明比原始计算的大小**成倍地短。**
-   **透明度：** 密码证明系统的全局参数，用于生成和验证证明，**没有陷门（trapdoors）**。这与依赖受信任方根据秘密信息对公共参数进行采样的证明系统形成对比，后者可以用作“陷门”来破坏证明系统的安全性。

在这篇文章的最后，你将对可扩展性和透明度的属性从何而来有一个非正式的了解。

我们在这里简要地指出，STARK 只使用轻量级对称密码学（加密哈希函数），这使得它们**快速**且（似乎）**是后量子安全的**。这与许多其他加密证明形成对比，其他加密证明的安全性依赖于公钥加密，这种加密对量子计算机来说既昂贵又不安全。

## 这篇文章的路线图

已知的 STARK 结构结合了两种成分：

1.  可以通过随机且廉价的本地检查来验证的长证明；和
2.  [加密哈希函数](https://en.wikipedia.org/wiki/Cryptographic_hash_function "加密哈希函数")，例如 SHA-256 或 Keccak。

非正式地，第一个组件为 STARK 提供了可扩展性，而第二个组件为 STARK 提供了透明度（不妨碍可扩展性）。在接下来的几节中，我们将详细介绍上述蓝图。

-   首先，我们描述*Micali construction*，一种遵循上述蓝图构造密码证明的方法。构成这种结构的证明系统称为概率可检查证明(PCP)。我们出于教学原因来描述这种结构：它是我们使用的结构的一个优雅的特例。
-   其次，我们解释了为什么 Micali 结构提供了透明度和可扩展性。
-   第三，我们描述了交互式预言机证明(IOP) 的概念，它概括了 PCP 并能够设计更高效的协议。我们还解释了之前帖子中的算术化和低度测试协议是如何成为 IOP 的。
-   最后，我们提到了*BCS construction*，它是 Micali 结构的扩展，它使用更通用的 IOP 概念而不是 PCP。**高效的 STARK，包括我们使用的那些，都是通过 BCS 构造获得的**。

## 来自 PCP 的密码证明，通过 Micali 结构

在本节中，我们将介绍[*概率可检查证明*](https://en.wikipedia.org/wiki/Probabilistically_checkable_proof "概率可检查证明")(PCP)，这是一种涉及**对长证明进行随机本地检查**的证明系统。然后我们解释了如何将 PCP 与轻量级密码学相结合以获得 STARK。这个结构来自[Silvio Micali的一篇论文（基于](https://dl.acm.org/citation.cfm?id=586984 "Silvio Micali的一篇论文（基于")[Joe Kilian](https://dl.acm.org/citation.cfm?id=129782 "Joe Kilian")的先前工作）。

*概率可检查证明*( PCP) 是PCP 证明者和 PCP 验证者之间的协议，它能够通过**对长证明的随机本地检查来**建立计算完整性 (CI) 语句的正确性。给定一个 CI 语句（*𝐀*，*x*，*y*，*T*），PCP 证明者生成一个证明字符串 𝚿，它“编码”了 CI 语句的计算轨迹。虽然证明 𝚿 比 T 步计算轨迹长（𝚿 的长度在 T 中是拟线性的），但 𝚿 具有显着特征，即它可以通过仅读取 𝚿 一小部分的概率测试来验证。即，给定相同的 CI 语句 ( *A* , *x* ,*y* , *T* )，PCP 验证者可以通过随机读取 𝚿 的少量位置来验证 𝚿，然后对读取的值运行廉价的“本地检查”。（读取位置的数量可以是一个小的常数，例如 3，与 T 无关！）如果 CI 语句为真，则验证者始终接受。相反，如果 CI 语句为假，则验证者以高概率拒绝，而不管证明字符串 𝚿 是如何选择的。有关图表，请参见图 2。

![图 2：概率可检查证明 (PCP) 示意图。](https://miro.medium.com/max/1400/1*J5nyQyz5eODAj1c5ViXv3g.png "图 2：概率可检查证明 (PCP) 示意图。")

回想一下，我们的目标是生成简短且快速验证的证明𝛑。这与 PCP 完全不同，PCP 涉及廉价的本地检查到长证明𝚿。那么我们如何从 𝚿 到 𝛑 呢？

可能会想到的一个自然想法是让证明者代表验证者对 𝚿 的本地视图进行**预采样**，然后将此本地视图作为证明 𝛑 发送。更详细地说，证明者*模拟*PCP 验证者对长证明 𝚿 进行随机本地检查，然后在证明 𝛑 中仅包含通过该本地检查读取的 𝚿 位置；证明者还在 𝛑 中包含用于 PCP 验证者的随机性 𝛒。（请注意，𝛑 很短，因为 𝚿 的读取位置数量很少。）预采样的直觉是，为了验证 𝛑，可以以相同的随机性 𝛒 运行 PCP 验证程序，这将导致读取𝚿 的位置与 𝛑 中的位置完全相同。然而，这个动人的想法是有缺陷的。首先，作弊证明者可能在 𝛑 中包含一个“随机性”选择 𝛒，事实上，这不是随机的。其次，作弊证明者可能会选择*依赖*于𝛒的 PCP 验证者查询的答案，以便通过 PCP 验证者的本地检查。这是可能的，因为 PCP 的安全性依赖于 𝚿 是*不可变* （*immutable*）的，即在选择验证者的随机本地检查之前固定。

上述问题可以通过使用任何[加密哈希函数](https://en.wikipedia.org/wiki/Cryptographic_hash_function "加密哈希函数")H 来解决，例如 SHA-256（建模为[随机预言](https://en.wikipedia.org/wiki/Random_oracle "随机预言")机），以实现**安全预采样**。这里的“安全”意味着证明者将能够让验证者相信短证明𝛑中包含的信息是在一些长证明𝚿上运行的“诚实”随机本地检查。

非正式地，如图 3 所示，证明者需要使用哈希函数 H 通过[Merkle 树](https://en.wikipedia.org/wiki/Merkle_tree "Merkle 树")提交长证明 𝚿 ，然后通过使用 H 对 Merkle 树的根进行哈希得到随机性 𝛒。这确保了随机性 𝛒 是“类随机的”（因为 𝛒 是哈希函数 H 的输出），并且还确保在 *之后* 选择 𝛒证明者已提交𝚿。现在证明者可以如上所述进行预采样，即它模拟 PCP 验证者对随机性 𝛒 的随机本地检查，以确定 𝚿 的哪些位置应该包含在 𝛑 中。最后，证明者通过在 𝛑 中包含每个选定位置的身份验证路径（位置的身份验证路径由从该位置到根的路径上的节点的兄弟姐妹组成）来“解除”选定位置。认证路径表明，𝚿 的声明值与 Merkle 根一致，特别是证明者随机性 𝛒 从root派生之后，证明和没有选择。总体而言，**简短证明 𝛑 将仅包括声明的 Merkle 树的根、声明的所选位置的 𝚿 值以及每个这些值的身份验证路径**（相对于根）。然后可以通过针对根检查声明值的所有身份验证路径，从根重新导出随机性 𝛒，并检查 PCP 验证程序在以随机性 𝛒 运行时是否接受声明值来验证 𝛑。¹

总而言之，我们使用哈希函数 H 来实现“安全预采样”，它可以在短证明 𝛑 中包含对长证明 𝚿 的单个随机本地检查。

\[1]：为什么安全预采样有效的这种“理由”只是直觉，获得正式的安全证明需要一些工作。例如，恶意证明者可以尝试提交许多不同的证明 𝚿 以寻找随机性的“有利”选择 𝛒，然后将这个有利的选择包含在 𝛑 中。安全性证明必须确定这样的证明者，实际上是任何有效的证明者，都极有可能失败。

![图 3：Micali 结构图，它使用加密哈希函数对 PCP 进行安全预采样。](https://miro.medium.com/max/1400/1*huskSC7pRAm0Zwkav44FXw.png "图 3：Micali 结构图，它使用加密哈希函数对 PCP 进行安全预采样。")

## 透明度来自密码学

Micali 结构的一个重要特征是，生成或验证短证明 𝛑 所需的唯一密码是[密码哈希函数](https://en.wikipedia.org/wiki/Cryptographic_hash_function "密码哈希函数")H（例如，SHA-256 或 Keccak）。因此，H 的选择是证明系统的所有用户都需要知道的唯一“全局参数”，并且可以通过*公共*信息做出该选择。这意味着通过 Micali 结构获得的密码证明是**透明**的。

上述内容与其他密码证明形成对比，其中产生或验证证明需要使用基于*秘密*信息产生的全局参数。对于那些熟悉基于配对的密码证明的人来说，全局参数的一个典型例子是

(G, 𝛂·G, 𝛂²·G, 𝛂³·G, …)

其中 G 是群元素，𝛂 是 *秘密* 标量。此类全局参数必须由受信任方或通过[多方仪式](https://z.cash/technology/paramgen/ "多方仪式")采样，因为用户不应该知道“陷门”𝛂。事实上，知道 𝛂 可以为虚假陈述生成看起来有效的证据。

## 可扩展性来自概率证明

Micali 结构的另一个重要特征是生成/验证短证明 𝛑 的时间接近生成/验证长证明 𝚿 的时间。这仅仅是因为与 PCP 操作相比，所需的加密操作成本较低。因此，我们了解到 Micali 结构的效率基本上取决于底层 PCP 的效率。特别是，**如果 PCP 是可扩展的**（生成 𝚿 需要时间在 T 中是准线性的，而验证 𝚿 是指数级的更快）**，那么 Micali 构造会产生可扩展的密码证明**。可扩展 PCP 的构造是已知的（参见[本文](https://eccc.weizmann.ac.il//report/2012/045/ "本文")）。

不幸的是，PCP 的成本仍然很高，这使得它们不适合实际使用。正因为如此，STARK 的实现不是基于通过 Micali 结构的 PCP。相反，它们基于另一种类型的概率证明，可以实现可扩展性，具有良好的具体成本，甚至零知识。我们接下来讨论这个。

## IOP：概率证明的新概念

高效的 STARK 基于一种称为[*交互式预言机证明*](https://eprint.iacr.org/2016/116 "交互式预言机证明")(IOP) 的概率证明系统，

该系统于 2015 年推出。非正式地，证明者和验证者参与交互协议，在每一轮验证者发送一些随机性 𝛔ᵢ 到证明者，证明者回复一个长证明𝚿ᵢ。在交互结束时，验证者对证明者在整个交互过程中发送的\_所有\_长证明（𝚿₁，𝚿₂，...）执行随机本地检查。有关图表，请参见图 4。请注意，PCP 只是一种“非交互式 IOP”，因此是一种受限情况。

![图 4：交互式预言机证明 (IOP) 示意图。这个概念扩展了 PCP 的概念（参见图 2）。](https://miro.medium.com/max/1400/1*zr0JBa8DCeNh6qJuLT-GqA.png "图 4：交互式预言机证明 (IOP) 示意图。这个概念扩展了 PCP 的概念（参见图 2）。")

在过去的几年中，研究人员开发了许多用于构建高效 IOP 的设计原则：[\[BCGV16\]](https://eprint.iacr.org/2016/021 "\[BCGV16]")、[\[BCGRS16\]](https://eprint.iacr.org/2016/324 "\[BCGRS16]")、[\[BB+16\]](https://eprint.iacr.org/2016/646 "\[BB+16]")、[\[BBGR16\]](https://eccc.weizmann.ac.il/report/2016/149/ "\[BBGR16]")、[\[BCFGRS16\]](https://eprint.iacr.org/2016/988 "\[BCFGRS16]")、[\[BBHR17\]](https://eccc.weizmann.ac.il/report/2017/134/ "\[BBHR17]")、[\[BBHR18\]](https://eprint.iacr.org/2018/046 "\[BBHR18]")、[\[ BCRSVW18\]](https://eprint.iacr.org/2018/828 "\[ BCRSVW18]")、[\[BKS19\]](https://eccc.weizmann.ac.il/report/2018/090/ "\[BKS19]")、[\[BGKS19\]](https://eccc.weizmann.ac.il/report/2019/044/ "\[BGKS19]")。我们在 STARK 结构中使用的 IOP 协议与[\[BBHR18\]](https://eprint.iacr.org/2018/046 "\[BBHR18]")最密切相关。

## 以前的帖子描述了一种有效的 IOP

我们现在解释一下我们之前关于算术化和低度测试的帖子是如何实际描述有效的 IOP 的。在图 5 中，我们提供了此 IOP 的图表。协议的第一阶段是**算术**化，它将给定的 CI 语句 ( *𝐀* , *x* , *y* , *T* ) 转换为涉及在某些多项式上建立度数界限的问题。第二阶段是**低度测试**，它解决了后一个问题。我们总结了协议的工作流程。

**算术化**（图 5 中的蓝色区域） **。** 证明者和验证者将程序\_𝐀\_转换为多项式约束的集合，如我们在[算术化 I](https://medium.com/starkware/arithmetization-i-15c046390862 "算术化 I")中所述。此外，证明者运行由 ( *𝐀* , *x* , *y* , *T* ) 描述的计算，获得\_T\_步计算轨迹。

然后，如我们在[算术化 II](https://medium.com/starkware/arithmetization-ii-403c3b3f4355 "算术化 II")中所述，证明者对该轨迹进行编码以获得编码轨迹 𝚽，并将其发送给验证者。（这里证明者在发送𝚽之前不需要从验证者那里接收任何随机性。）之后，验证者发送随机性𝛔₀，这使得证明者和验证者都可以将所有多项式约束“捆绑”到一个\_单一的\_多项式约束，通过取它们的随机线性组合。证明者将后者与编码轨迹 𝚽 相结合，以获得复合多项式 𝚵，并将其发送给验证者。验证者通过本地一致性检查确保𝚽和𝚵适当相关。此时，如果局部一致性检查以高概率通过，则当且仅当 𝚽 和 𝚵 具有低度时，CI 语句为真。

**低度测试**（图 5 中的灰色区域） **。** 证明者使用 FRI 协议（在我们的[低度测试帖子](https://medium.com/starkware/low-degree-testing-f7614f5172db "低度测试帖子")中描述）来让验证者相信 𝚽 和 𝚵 是对低度多项式的赋值。这涉及到一个协议，其中验证者在每一轮发送一些随机性𝛔ᵢ，证明者回复一个辅助证明𝚿ᵢ，在协议结束时，验证者对𝚽、𝚵和𝚿ᵢ进行随机本地检查。如果 FRI 协议的验证者以高概率接受，则 𝚽 和 𝚵 具有所需的度数。如果是这样，验证者会得出结论，CI 语句 ( *𝐀* , *x* , *y* , *T* ) 是一个真实的语句。

![图 5：之前文章中描述的 IOP 协议图。](https://miro.medium.com/max/1400/1*mrKmtxV9hieym9yR1KcMtA.png "图 5：之前文章中描述的 IOP 协议图。")

## 通过 BCS 构造的密码证明

高效的 STARK 是通过[BCS 构造](https://eprint.iacr.org/2016/116 "BCS 构造")获得的，这是一种将 IOP 与密码哈希函数 H 相结合以获得密码证明的方法。这种方法是 Micali 结构的扩展，它保留了我们上面讨论的特性（透明性和可扩展性）。我们在这篇文章中没有描述 BCS 的构造，只是说它可以被视为在 IOP 的每一轮中应用 Micali 构造，并将每一轮的承诺放在哈希链中（这使得轮次保持有序）。

# 结论

在这篇文章中，我们解释了有效的 STARK 结构是通过结合**有效的 IOP**（一种概率证明）和**加密哈希函数**来获得的。IOP 赋予 STARK 可扩展性，而哈希函数赋予 STARK 透明度。不同的 STARK 结构在底层 IOP 上有所不同，我们已经解释了我们之前的帖子是如何描述我们的 STARK 结构中使用的 IOP 协议的组件的。

我们的 STARK 数学系列到此结束。我们希望它对您有价值！
