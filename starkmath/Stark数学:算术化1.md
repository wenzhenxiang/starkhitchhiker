# Stark数学：算术化1

原文链接：

[https://medium.com/starkware/arithmetization-i-15c046390862](https://medium.com/starkware/arithmetization-i-15c046390862 "https://medium.com/starkware/arithmetization-i-15c046390862")

这是我们关于 STARKs 背后的数学系列的第二部分（第一部分链接），也是关于算术化的两篇文章中的第一篇。

![](image/image_nmR830GdaJ.png)

照片由 Gayatri Malhotra 在 Unsplash 上拍摄&#x20;

当你阅读完这篇文章后，你应该对计算完整性（Computational Integrity）陈述如何转换为执行轨迹（execution trace）和多项式约束（polynomial constraints）这些有一个很好的了解。我们将从超市收银小票作为一个简单的例子开始，然后转到一个稍微复杂的例子，即 Collat​​z 序列，它与数论中一个众所周知的开放问题有关。我们将假设读者对有限域上的多项式和整数的二进制表示有基本的了解。

# 粗略讲述STARK

STARK 协议的目标是简洁且透明地进行验证计算。STARK 的第一步称为**算术化**（*arithmetization*），它是将验证计算问题转换为检查某个多项式的问题（通常称为“归约”，reduction），可以在验证者方面有效地评估（这是“简洁”部分） , 这部分是低度的（low degree）。算术化很有用，因为它可以使用纠错码等工具来有效地低度测试。然而，算术化本身仅将计算完整性陈述转换为多项式形式，为 STARK 的下一阶段做铺垫，这是另一种交互式协议，其中涉及一个证明者，该证明者试图说服验证者该多项式确实是低度的。当且仅当原始计算正确时，验证者确信多项式是低度的（除了极小的概率）。在 STARK 的最后一步中，交互协议被转换为单个非交互证明，可以发布到区块链并可由任何人进行公开验证。

算术化本身由两步组成：第一步是生成执行轨迹和多项式约束，第二步是将这两个对象转换为单个低度多项式。在证明者与验证者的交互方面，真正发生的是证明者和验证者事先就多项式约束的内容达成一致。然后，证明者生成一个执行轨迹，在随后的交互中，证明者试图让验证者相信在这个执行轨迹上满足多项式约束，而验证者看不到。

# 回顾——计算完整性声明

在[上一篇文章](https://starkware.substack.com/p/stark?r=1rzn6c\&utm_campaign=post\&utm_medium=web "上一篇文章")中，我们讨论了计算完整性 (CI) 陈述(statement )的概念，即从抽象的角度来看，某个计算的输出是正确的。让我们看一个计算完整性陈述的具体例子：当我们在超市购物时，收银小票中的总额是（默认）被正确计算的， 通常情况下，小票中会列出每个单品的价格和数量，并将计算的总额显示在底部，如下所示：

![](https://miro.medium.com/max/400/1*CGPR-4oKb7OuvvVoS974Rw.png)

为简单起见——我们先接受这个总额计算是正确的，为了验证计算完整性，我们可以将小票中的价格一一相加，计算出总和，并与小票上的总额进行一个对比。这是一个非常简单的示例，但我们将在本文后面进一步使用它来演示简洁可测试性（*succinct testability*）的概念。

# 算术化

算术化的第一步是取一些计算完整性陈述（如“区块 7218290 中的第五笔交易是正确的”），并将其翻译成正式的代数形式。这有两个目的：1) 它以明确的方式简洁地定义声明，2) 将声明嵌入到代数域中。这种嵌入是第二步允许算术化的原因，它将计算完整性陈述简化为关于特定多项式阶数的声明。

我们使用的代数表示有两个主要组成部分：1）一个可执行轨迹，2）一组多项式约束。执行轨迹是一个表，表示潜在计算的步骤，其中每一行代表一个步骤。构造多项式约束的集合，使得当且仅当迹线表示有效计算时，所有这些约束都得到满足。虽然执行轨迹可能很长，但我们将使用一组简洁的多项式约束。

## 执行轨迹

我们要生成的执行轨迹类型必须具有简洁可测试的特殊特征——每行只能根据轨迹中靠近它的行进行验证，并且对行与行之间应用相同的验证过程，这个特征直接影响证明的大小。为了说明我们所说的简洁可测试的意思，还是以超市收银小票举例，在收银小票中添加累计总额这一新列数据：

![](https://miro.medium.com/max/400/1*ASv07glmLXGrhUINS6o_4w.png)

这个新加的一列允许我们在给定它的前一行的情况下单独验证每一行，例如，我们可以检查这两行：

![](https://miro.medium.com/max/400/1*Rrt_B-VX0e2u3FqApx7Mog.png)

并确认这个特定的计算步骤（即数字 16.41）是正确的，因为 12.96+3.45=16.41。值得注意的是，相同的约束应用于行与行之间。这就是我们所说的**简洁**约束。

## 多项式约束

让我们以表格的形式重写收银小票（带有累计）：

![](https://miro.medium.com/max/400/1*tG7G7RUVacT55U2JIoDSXw.png)

用 $ A_{i,j}
  $表示第 i 行第 j 列中单元格的值。我们现在可以将正确性条件重新表述为这组多项式约束：

![](https://miro.medium.com/max/700/1*nJftq6cTkbyV9UYy3LDcdA.png)

这些是 $A_{i,j}$中的线性多项式约束。如果我们使用的多项式约束是高阶的，这会对证明大小和生成证明的时间产生负面影响。因此，我们线性约束是最好的。其中，第2）步的约束条件会使用多次，并且集合的整个大小与收银小票的长度无关。

总之，我们使用了计算完整性验证了超市收银小票，并将其转换为简洁可测试的执行轨迹，以及一组相应的多项式约束，当且仅当原始收银小票中的总和正确时才成立。

下面进行一个更为复杂的例子。

# Collatz 猜想

1937年，一位名叫Lothar Collatz的德国数学家在数论领域提出了一个猜想。多年来，它引起了许多数学家的注意，并获得了许多同义词（例如，3 *n* + 1 猜想、Ulam 猜想、角谷问题等等）。Paul Erdős 曾经谈到这个猜想：“数学可能还没有准备好解决这些问题”。

Collatz 序列以任何正整数开头，其中序列中的每个后续元素都从前一个元素中获得，如下所示：

-   如果前一个元素是偶数：将其除以 2得到下一个数。
-   如果前一个元素是奇数且大于 1：将其乘以 3 并加 1得到下一个数。
-   如果前一个元素为 1，则停止。

让我们考虑一个初始项为 52 的示例：

52 -> 26 -> 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1。

**Collatz 猜想：** 对于我们开始设置的任何正整数，序列最后总是会达到 1。

很遗憾，解决Collatz 猜想超出了这篇博文的范围。相反，我们将考虑验证计算的问题，该计算检查特定起始整数的猜想。

## Collatz 序列执行轨迹

计算完整性陈述是：“以 52 开始的 Collatz 序列，经过 11 次迭代后以 1 结束”。

令 A 为序列计算的执行轨迹。第 i 行，用$  A_i $表示，代表序列中的第 i 个数字。所有数字都表示为二进制字符串，以便更容易用多项式表示奇/偶条件。$A_{i,j}$等于序列的第 i 个数字的第j 个最低有效位。例如，A *0* =001011：第一项是 52，它的二进制表示是 110100，然后反转位的顺序（位反转顺序简化了多项式约束的索引，译者注：将二进制低位排列到左侧）。

以下是上述以 52 开头的 Collatz 序列的执行轨迹：

![](https://miro.medium.com/max/400/1*eKs7mOndYBhr67yu1zQbBw.png)

请注意，这里的执行轨迹有 6 列，因为 6 位足以表示序列中最大的数字。如果我们以 51 开始序列，那么下一个数字将是 154，所以51开始的序列的轨迹至少需要 8 列(译者注：154需要8位二进制表示)。

## Collatz 序列多项式约束

回想一下，我们正在寻找的多项式约束是这样的，当且仅当执行轨迹 A 描述给定的 Collatz 序列时（从 52 开始，以 1 结束，并且任何两行之间的转换都正确完成） 。在我们的例子中，执行轨迹  A 的大小为 6x12，即它表示 12 个 6 位数字的 Collatz 序列。多项式约束的集合如下（n=12，m=6）：

![](https://miro.medium.com/max/700/1*zaajlXV-OwJ2Tbo0wpKdEA.png)

让我们回顾一下每个约束。前三个很简单：

(1) 当且仅当第一行是 52 成立。

(2) 当且仅当最后一行是 1 成立。

(3) 确保表格中的每一个单元都是二进制位（一个数等于其平方，它只能是 0 或 1）。

第4）个约束定义了序列的简洁计算的核心，即每两个连续行之间的连接（译者注：其确保相邻两行之间的计算正确）。将计算约束表示为局部约束的重复模式（即简洁性）的能力，是验证者去验证比简单的重复计算速度快得多的基础。

让我们仔细检查约束本身。

对于任何 i\<n-1，表示：

![](https://miro.medium.com/max/700/1*4LRiykrWB9rqddFp7MPb9w.png)

因此，对于每个 i\<n-1，我们得到以下约束：

![](https://miro.medium.com/max/700/1*3j0FuyCZkrKiMb7R5ucZfw.png)

$A_{i,0}$是第 i 个数的最低有效位，它决定了它的奇偶校验为一个整数，所以这个约束描述了 Collatz 序列规则。

总而言之，当且仅当执行轨迹表示 Collatz 序列的有效计算时，才满足所有约束条件。

请注意，任何长度为 n 的 Collatz 序列都可以使用大小为 n\*m 的轨迹来表示，其中 m 是表示序列中数字的最大位数，并且相应地修改了相应的多项式约束。请注意，多项式约束不会随 n 和 m 增长，而是保持简单和简洁。给定 Collatz 序列的特定第一项，一个简单的计算机程序可以输出执行轨迹和多项式约束。

# 结论

在这篇文章中，我们介绍了计算完整性陈述算术化的第一步。

我们已经看到如何将有关 Collatz 序列的计算完整性陈述转换为执行轨迹和一组简洁描述的多项式约束。类似的方法可以用来转换任何计算，一般来说，任何计算完整性陈述都可以转换成这种形式。然而，细节很重要。虽然执行轨迹（和一组多项式约束）可以通过多种方式描述特定计算，但其中只有少数产生一个可以有效构建的小型 STARK 证明。StarkWare 中的大部分工作都致力于设计能产生良好简约的多项式约束，我们称之为 AIR（Algebraic Intermediate Representation，代数中间表示），因为我们系统的大部分性能都依赖于它。

在下一篇文章中，我们将介绍算术化的第二步——将执行轨迹和多项式约束转换为单个多项式，当且仅当原始计算正确时，该多项式保证为低度数。

*Kineret Segal & Shir Peled*

*StarkWare*

翻译：

Xiang
